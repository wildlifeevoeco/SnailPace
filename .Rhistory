full.snails <- merge(ssa.snails, day.snails, by.x = 'date.snails', by.y = 'Date', all.x = T)
# Specify phase -- day between sunrise and sunset, otherwise night
full.snails[,'ToD_start'] <- ifelse((full.snails$SunriseDate < full.snails$t1_ & full.snails$t1_ < (full.snails$SunsetDate)),
'day', 'night')
dat <- fread(paste0(raw, 'UTMControlcsv.csv'))
View(dat)
full.snails <- setDT(full.snails)
dat <- dat[,.(Date, Snail, Treatment, Stage, Time, Temperature, Precip)]
dat$datetime <- paste(dat$Date, dat$Time)
# making sure my newly created datetime is the right str
dat$datetime <- as.POSIXct(dat$datetime, tz = 'UTC', "%Y-%m-%d %H:%M")
merged.snails <-merge(full.snails, dat[,.(Snail, datetime, Temperature, Precip, Treatment, Stage)], by.x=c('treatment','t2_'), by.y= c('Snail', 'datetime'), all.x=T)
View(merged.snails)
# get rid of now unneeded sunrise/sunset columns -- yours will probably be something like this in the end
ssa.snails2019 <- setDT(merged.snails)[,.(burst_, step_id_, case_, snail,  x1_, y1_, x2_, y2_, t1_, t2_, dt_, sl_, log_sl, ta_, cos_ta, ToD_start,
Temperature, Precip, edgedist, Treatment )]
# get rid of now unneeded sunrise/sunset columns -- yours will probably be something like this in the end
ssa.snails2019 <- setDT(merged.snails)[,.(burst_, step_id_, case_, Snail,  x1_, y1_, x2_, y2_, t1_, t2_, dt_, sl_, log_sl, ta_, cos_ta, ToD_start,
Temperature, Precip, edgedist, treatment )]
# get rid of now unneeded sunrise/sunset columns -- yours will probably be something like this in the end
ssa.snails2019 <- setDT(merged.snails)[,.(burst_, step_id_, case_, snail,  x1_, y1_, x2_, y2_, t1_, t2_, dt_, sl_, log_sl, ta_, cos_ta, ToD_start,
Temperature, Precip, edgedist, treatment )]
merged.snails <-merge(full.snails, dat[,.(Snail, datetime, Temperature, Precip, Treatment, Stage)], by.x=c('treatment','t2_'), by.y= c('Snail', 'datetime'), all.x=T)
### Packages ----
libs <- c('data.table', 'dplyr', 'amt', 'raster', 'tidyr', 'ggplot2') # you might need lubridate
lapply(libs, require, character.only = TRUE)
### Input data ----
raw <- '~/Honours stuff/Snails/Data/raw/' # folder I store raw data here
derived <- '~/Honours stuff/Snails/Data/derived/' #this is the folder where I'll put my new data after I extract the covariates, as we'll be doing here
### data ----
dat <- fread(paste0(raw, 'SnailDataUTM.csv')) #my data
#'amt' needs a date time in this format with the date and time all in one
dat$datetime <- paste(dat$Date, dat$Time)
# making sure my newly created datetime is the right str
dat$datetime <- as.POSIXct(dat$datetime, tz = 'UTC', "%Y-%m-%d %H:%M")
### setting my crs ----
utm22T <- "+proj=utm +zone=22 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"
crs22 <- sp::CRS("+init=epsg:32621")
# selecting just the parts of the data that I need, you'll probably need to include your other things like temp and precip
DT.prep <- dat %>% dplyr::select(x = "xUTM", y = "yUTM", t = 'datetime', snail = 'Snail', temp = "Temperature", precip = "Precipitation", treatment = "Treatment", stage = "Stage")
# prepping structure for amt (they really like tidyvers, and it's kind of annoyingly dependent on it)
# nesting data by id
dat_all <- DT.prep %>% group_by(treatment) %>% nest()
#making the track
dat_all <- dat_all %>%
mutate(trk = map(data, function(d) {
amt::make_track(d, x, y, t, crs = sp::CRS("+init=epsg:32621"))
}))
#summary of track sampling rate for each individual
dat_all %>% mutate(sr = lapply(trk, summarize_sampling_rate)) %>%
dplyr::select(treatment, sr) %>% unnest(cols = c(sr))
#### layers ####
# load proximity rasters
edge <- raster(paste0(raw, 'edgedist.tif'), )
brickedge1 <- raster(paste0(raw, 'brickedge1.tif'), )
brickedge2 <- raster(paste0(raw, 'brickedge2.tif'), )
brickedge3 <- raster(paste0(raw, 'brickedge3.tif'), )
#### making steps from track and extracting covariates ####
ssa <- dat_all %>%
mutate(steps = map(trk, function(x) {
x %>% amt::track_resample(rate = minutes(30), tolerance = minutes(10)) %>%
amt::filter_min_n_burst(min_n = 3) %>%
amt::steps_by_burst() %>% amt::random_steps(n=10) %>%
amt::extract_covariates(edge, where = "both")  %>% # both indicates you want the covariate at the start and end of the step
amt::extract_covariates(brickedge1, where = "both") %>%
amt::extract_covariates(brickedge2, where = "both") %>%
amt::extract_covariates(brickedge3, where = "both") %>%
amt::time_of_day(t, where = 'start') %>%  # calc day/night ToD, only for start of the step
#you propbably won't need to do the land_start/_end renaming since you don't have any categorical rasters, but just in case some go on the brick, and you want to know if they're on the brick or not?
mutate( log_sl = log(sl_), # adding log transformed SL *DO THIS*
cos_ta = cos(ta_)) # adding cos transformed TA *DO THIS*
}))
# unnest the data
ssa.all <- ssa %>% dplyr::select(treatment, steps) %>% unnest(cols = c(steps))
View(ssa.all)
# unnest the data
ssa.all <- ssa %>% dplyr::select(treatment,snail, steps) %>% unnest(cols = c(steps))
View(ssa)
View(ssa)
View(ssa)
View(ssa[[2]][[1]])
# unnest the data
ssa.all <- ssa %>% dplyr::select(treatment, steps) %>% unnest(cols = c(steps, data))
# unnest the data
ssa.all <- ssa %>% dplyr::select(treatment, steps) %>% unnest(cols = c(steps, ssa$data))
# unnest the data
ssa.all <- ssa %>% dplyr::select(treatment, steps) %>% unnest(cols = c(steps, ssa$data$snail))
# unnest the data
ssa.all <- ssa %>% dplyr::select(treatment, steps) %>% unnest(cols = c(steps))
View(ssa.all)
View(DT.prep)
XXX<-merge(ssa.all, DT.prep[,.(snail, t, temp, precip, stage)], by.x=c('treatment','t2_'), by.y= c('treatment', 't'), all.x=T)
XXX<-merge(ssa.all, DT.prep[,.(snail, t, temp, precip, stage)], by.x=c('treatment','t2_'), by.y= c('snail', 't'), all.x=T)
View(XXX)
View(DT.prep)
XXX<-merge(ssa.all, DT.prep[,.(snail, t, temp, precip, stage)], by.x=c('treatment','t2_'), by.y= c('treatment', 't'), all.x=T)
XXX<-merge(ssa.all, DT.prep[,.(snail, t, temp, precip, stage)], by.x=c('treatment','t2_'), by.y= c('stage', 't'), all.x=T)
View(DT.prep)
### Packages ----
libs <- c('data.table', 'dplyr', 'lubridate', 'tidyr')
lapply(libs, require, character.only = TRUE)
### Input data ----
raw <- '~/Honours stuff/Snails/Data/raw/'
derived <- '~/Honours stuff/Snails/Data/derived/'
# Read in Sunset/Sunrise times ####
#in the csv, make sure you have these columns, sometimes the website does weird formatting: Date, `Civil Twilight Start`, Sunrise, Sunset, `Civil Twilight End`
ss2019 <- fread(paste0(raw,"SunriseSunset.csv"), header=TRUE) # read in csv of times
ss2019[,'Year'] <- 2019 # need to add year so it will be the right format to merge later
ss2019[,'dateyear'] <- paste(ss2019$Year, ss2019$Date, sep = '-') # building right format yyyy-mm-dd
day <- ss2019[,.(Date = dateyear, Sunrise = Sunrise, Sunset = Sunset)] #renaming so it's easier
day[,'Date'] <- as.POSIXct(day$Date, tz = 'UTC', "%Y-%m-%d") #formatting (dates are stupid in R)
day[,'SunriseDate'] <- as.POSIXct(paste(day$Date, day$Sunrise, sep = ' '), tz = 'UTC', "%Y-%m-%d %H:%M")
day[,'SunsetDate'] <- as.POSIXct(paste(day$Date, day$Sunset, sep = ' '), tz = 'UTC', "%Y-%m-%d %H:%M")
# Save RDS
saveRDS(day, '~/Honours stuff/Snails/Data/derived/sunsetsunrise2019.Rds')
# Read in prepped Sunset/Sunrise times
day.snails <- readRDS('~/Honours stuff/Snails/Data/derived/sunsetsunrise2019.Rds')
# Read in SSA data
ssa.snails <- readRDS("~/Honours stuff/Snails/Data/derived/ssaAllTreats.Rds")
ssa.snails[,"date.snails"] <- as.POSIXct(format(ssa.snails$t1_, "%Y-%m-%d"), tz = 'UTC', "%Y-%m-%d")
# Merge based on Date
full.snails <- merge(ssa.snails, day.snails, by.x = 'date.snails', by.y = 'Date', all.x = T)
# Specify phase -- day between sunrise and sunset, otherwise night
full.snails[,'ToD_start'] <- ifelse((full.snails$SunriseDate < full.snails$t1_ & full.snails$t1_ < (full.snails$SunsetDate)),
'day', 'night')
dat <- fread(paste0(raw, 'UTMControlcsv.csv'))
full.snails <- setDT(full.snails)
View(full.snails)
dat <- dat[,.(Date, Snail, Treatment, Stage, Time, Temperature, Precip)]
View(dat)
dat$datetime <- paste(dat$Date, dat$Time)
# making sure my newly created datetime is the right str
dat$datetime <- as.POSIXct(dat$datetime, tz = 'UTC', "%Y-%m-%d %H:%M")
merged.snails <-merge(full.snails, dat[,.(Snail, datetime, Temperature, Precip, Treatment, Stage)], by.x=c('treatment','t2_'), by.y= c('Snail', 'datetime'), all.x=T)
View(merged.snails)
merged.snails <-merge(full.snails, dat[,.(snail, datetime, Temperature, Precip, Treatment, Stage)], by.x=c('treatment','t2_'), by.y= c('Snail', 'datetime'), all.x=T)
View(dat)
merged.snails <-merge(full.snails, dat[,.(Snail, datetime, Temperature, Precip, Treatment, Stage)], by.x=c('treatment','t2_'), by.y= c('Snail', 'datetime'), all.x=F)
merged.snails <-merge(full.snails, dat[,.(Snail, datetime, Temperature, Precip, Treatment, Stage)], by.x=c('treatment','t2_'), by.y= c('Snail', 'datetime'), all.x=T)
# get rid of now unneeded sunrise/sunset columns -- yours will probably be something like this in the end
ssa.snails2019 <- setDT(merged.snails)[,.(burst_, step_id_, case_, snail,  x1_, y1_, x2_, y2_, t1_, t2_, dt_, sl_, log_sl, ta_, cos_ta, ToD_start,
Temperature, Precip, edgedist, treatment )]
# get rid of now unneeded sunrise/sunset columns -- yours will probably be something like this in the end
ssa.snails2019 <- setDT(merged.snails)[,.(burst_, step_id_, case_, Snail,  x1_, y1_, x2_, y2_, t1_, t2_, dt_, sl_, log_sl, ta_, cos_ta, ToD_start,
Temperature, Precip, edgedist, treatment )]
# get rid of now unneeded sunrise/sunset columns -- yours will probably be something like this in the end
ssa.snails2019 <- setDT(merged.snails)[,.(burst_, step_id_, case_, dat$Snail,  x1_, y1_, x2_, y2_, t1_, t2_, dt_, sl_, log_sl, ta_, cos_ta, ToD_start,
Temperature, Precip, edgedist, treatment )]
# get rid of now unneeded sunrise/sunset columns -- yours will probably be something like this in the end
ssa.snails2019 <- setDT(merged.snails)[,.(burst_, step_id_, case_, dat$Snail,  x1_, y1_, x2_, y2_, t1_, t2_, dt_, sl_, log_sl, ta_, cos_ta, ToD_start,
Temperature, Precip, edgedist_end, edgedist_start, treatment )]
View(ssa.snails2019)
View(full.snails)
View(dat)
# get rid of now unneeded sunrise/sunset columns -- yours will probably be something like this in the end
ssa.snails2019 <- setDT(merged.snails)[,.(burst_, step_id_, case_, dat$Snail,  x1_, y1_, x2_, y2_, t1_, t2_, dt_, sl_, log_sl, ta_, cos_ta, ToD_start,
dat$Temperature, dat$Precip, edgedist_end, edgedist_start, brickdist1_start, brickdist1_end, brickdist2_start,
brickdist2_end, brickdist3_start, brickdist3_end,treatment )]
View(merged.snails)
# get rid of now unneeded sunrise/sunset columns -- yours will probably be something like this in the end
ssa.snails2019 <- setDT(merged.snails)[,.(burst_, step_id_, case_, dat$Snail,  x1_, y1_, x2_, y2_, t1_, t2_, dt_, sl_, log_sl, ta_, cos_ta, ToD_start,
dat$Temperature, dat$Precip, edgedist_end, edgedist_start, brickedge1_start, brickedge1_end, brickedge2_start,
brickedge2_end, brickedge3_start, brickedge3_end,treatment )]
View(ssa.snails2019)
# get rid of now unneeded sunrise/sunset columns -- yours will probably be something like this in the end
ssa.snails2019 <- setDT(merged.snails)[,.(burst_, step_id_, case_, Snail,  x1_, y1_, x2_, y2_, t1_, t2_, dt_, sl_, log_sl, ta_, cos_ta, ToD_start,
Temperature, Precip, edgedist_end, edgedist_start, brickedge1_start, brickedge1_end, brickedge2_start,
brickedge2_end, brickedge3_start, brickedge3_end,treatment )]
# get rid of now unneeded sunrise/sunset columns -- yours will probably be something like this in the end
ssa.snails2019 <- setDT(merged.snails)[,.(burst_, step_id_, case_,  x1_, y1_, x2_, y2_, t1_, t2_, dt_, sl_, log_sl, ta_, cos_ta, ToD_start,
Temperature, Precip, edgedist_end, edgedist_start, brickedge1_start, brickedge1_end, brickedge2_start,
brickedge2_end, brickedge3_start, brickedge3_end,treatment )]
# get rid of now unneeded sunrise/sunset columns -- yours will probably be something like this in the end
ssa.snails2019 <- setDT(merged.snails)[,.(burst_, step_id_, case_,  x1_, y1_, x2_, y2_, t1_, t2_, dt_, sl_, log_sl, ta_, cos_ta, ToD_start,
Temperature, Precip, edgedist_end, edgedist_start, brickedge1_start, brickedge1_end, brickedge2_start,
brickedge2_end, brickedge3_start, brickedge3_end,treatment )]
View(ssa.snails2019)
View(ssa.snails)
# Read in Sunset/Sunrise times ####
#in the csv, make sure you have these columns, sometimes the website does weird formatting: Date, `Civil Twilight Start`, Sunrise, Sunset, `Civil Twilight End`
ss2019 <- fread(paste0(raw,"SunriseSunset.csv"), header=TRUE) # read in csv of times
ss2019[,'Year'] <- 2019 # need to add year so it will be the right format to merge later
ss2019[,'dateyear'] <- paste(ss2019$Year, ss2019$Date, sep = '-') # building right format yyyy-mm-dd
day <- ss2019[,.(Date = dateyear, Sunrise = Sunrise, Sunset = Sunset)] #renaming so it's easier
day[,'Date'] <- as.POSIXct(day$Date, tz = 'UTC', "%Y-%m-%d") #formatting (dates are stupid in R)
day[,'SunriseDate'] <- as.POSIXct(paste(day$Date, day$Sunrise, sep = ' '), tz = 'UTC', "%Y-%m-%d %H:%M")
day[,'SunsetDate'] <- as.POSIXct(paste(day$Date, day$Sunset, sep = ' '), tz = 'UTC', "%Y-%m-%d %H:%M")
# Save RDS
saveRDS(day, '~/Honours stuff/Snails/Data/derived/sunsetsunrise2019.Rds')
# Read in prepped Sunset/Sunrise times
day.snails <- readRDS('~/Honours stuff/Snails/Data/derived/sunsetsunrise2019.Rds')
# Read in SSA data
ssa.snails <- readRDS("~/Honours stuff/Snails/Data/derived/ssaAll.Rds")
ssa.snails[,"date.snails"] <- as.POSIXct(format(ssa.snails$t1_, "%Y-%m-%d"), tz = 'UTC', "%Y-%m-%d")
# Merge based on Date
full.snails <- merge(ssa.snails, day.snails, by.x = 'date.snails', by.y = 'Date', all.x = T)
# Specify phase -- day between sunrise and sunset, otherwise night
full.snails[,'ToD_start'] <- ifelse((full.snails$SunriseDate < full.snails$t1_ & full.snails$t1_ < (full.snails$SunsetDate)),
'day', 'night')
dat <- fread(paste0(raw, 'UTMControlcsv.csv'))
full.snails <- setDT(full.snails)
dat <- dat[,.(Date, Snail, Treatment, Time, Temperature, Precip)]
dat$datetime <- paste(dat$Date, dat$Time)
# making sure my newly created datetime is the right str
dat$datetime <- as.POSIXct(dat$datetime, tz = 'UTC', "%Y-%m-%d %H:%M")
merged.snails <-merge(full.snails, dat[,.(Snail, datetime, Temperature, Precip, Treatment)], by.x=c('snail','t2_'), by.y= c('Snail', 'datetime'), all.x=T)
# get rid of now unneeded sunrise/sunset columns -- yours will probably be something like this in the end
ssa.snails2019 <- setDT(merged.snails)[,.(burst_, step_id_, case_, snail,  x1_, y1_, x2_, y2_, t1_, t2_, dt_, sl_, log_sl, ta_, cos_ta, ToD_start,
Temperature, Precip, edgedist, Treatment )]
View(merged.snails)
### Packages ----
libs <- c('data.table', 'dplyr', 'amt', 'raster', 'tidyr', 'ggplot2') # you might need lubridate
lapply(libs, require, character.only = TRUE)
### Input data ----
raw <- '~/Honours stuff/Snails/Data/raw/' # folder I store raw data here
derived <- '~/Honours stuff/Snails/Data/derived/' #this is the folder where I'll put my new data after I extract the covariates, as we'll be doing here
### data ----
dat <- fread(paste0(raw, 'SnailDataUTM.csv')) #my data
#'amt' needs a date time in this format with the date and time all in one
dat$datetime <- paste(dat$Date, dat$Time)
# making sure my newly created datetime is the right str
dat$datetime <- as.POSIXct(dat$datetime, tz = 'UTC', "%Y-%m-%d %H:%M")
### setting my crs ----
utm22T <- "+proj=utm +zone=22 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"
crs22 <- sp::CRS("+init=epsg:32621")
# selecting just the parts of the data that I need, you'll probably need to include your other things like temp and precip
DT.prep <- dat %>% dplyr::select(x = "xUTM", y = "yUTM", t = 'datetime', snail = 'Snail', temp = "Temperature", precip = "Precipitation", treatment = "Treatment", stage = "Stage")
# prepping structure for amt (they really like tidyvers, and it's kind of annoyingly dependent on it)
# nesting data by id
dat_all <- DT.prep %>% group_by(snail) %>% nest()
#making the track
dat_all <- dat_all %>%
mutate(trk = map(data, function(d) {
amt::make_track(d, x, y, t, crs = sp::CRS("+init=epsg:32621"))
}))
#summary of track sampling rate for each individual
dat_all %>% mutate(sr = lapply(trk, summarize_sampling_rate)) %>%
dplyr::select(treatment, sr) %>% unnest(cols = c(sr))
#summary of track sampling rate for each individual
dat_all %>% mutate(sr = lapply(trk, summarize_sampling_rate)) %>%
dplyr::select(snail, sr) %>% unnest(cols = c(sr))
dat_all <- setDT(dat_all)
dat_all <- setDT(dat_all)
#### layers ####
# load proximity rasters
edge <- raster(paste0(raw, 'edgedist.tif'), )
brickedge1 <- raster(paste0(raw, 'brickedge1.tif'), )
brickedge2 <- raster(paste0(raw, 'brickedge2.tif'), )
brickedge3 <- raster(paste0(raw, 'brickedge3.tif'), )
#### making steps from track and extracting covariates ####
ssa <- dat_all %>%
mutate(steps = map(trk, function(x) {
x %>% amt::track_resample(rate = minutes(30), tolerance = minutes(10)) %>%
amt::filter_min_n_burst(min_n = 3) %>%
amt::steps_by_burst() %>% amt::random_steps(n=10) %>%
amt::extract_covariates(edge, where = "both")  %>% # both indicates you want the covariate at the start and end of the step
amt::extract_covariates(brickedge1, where = "both") %>%
amt::extract_covariates(brickedge2, where = "both") %>%
amt::extract_covariates(brickedge3, where = "both") %>%
amt::time_of_day(t, where = 'start') %>%  # calc day/night ToD, only for start of the step
#you propbably won't need to do the land_start/_end renaming since you don't have any categorical rasters, but just in case some go on the brick, and you want to know if they're on the brick or not?
mutate( log_sl = log(sl_), # adding log transformed SL *DO THIS*
cos_ta = cos(ta_)) # adding cos transformed TA *DO THIS*
}))
### Packages ----
libs <- c('data.table', 'dplyr', 'amt', 'raster', 'tidyr', 'ggplot2') # you might need lubridate
lapply(libs, require, character.only = TRUE)
### Input data ----
raw <- '~/Honours stuff/Snails/Data/raw/' # folder I store raw data here
derived <- '~/Honours stuff/Snails/Data/derived/' #this is the folder where I'll put my new data after I extract the covariates, as we'll be doing here
### data ----
dat <- fread(paste0(raw, 'UTMTreat1.csv')) #my data
#'amt' needs a date time in this format with the date and time all in one
dat$datetime <- paste(dat$Date, dat$Time)
# making sure my newly created datetime is the right str
dat$datetime <- as.POSIXct(dat$datetime, tz = 'UTC', "%Y-%m-%d %H:%M")
### setting my crs ----
utm22T <- "+proj=utm +zone=22 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"
crs22 <- sp::CRS("+init=epsg:32621")
# selecting just the parts of the data that I need, you'll probably need to include your other things like temp and precip
DT.prep <- dat %>% dplyr::select(x = "xUTM", y = "yUTM", t = 'datetime', snail = 'Snail', temp = "Temperature", precip = "Precip")
# selecting just the parts of the data that I need, you'll probably need to include your other things like temp and precip
DT.prep <- dat %>% dplyr::select(x = "xUTM", y = "yUTM", t = 'datetime', snail = 'Snail', temp = "Temperature", precip = "Precipitation")
# prepping structure for amt (they really like tidyvers, and it's kind of annoyingly dependent on it)
# nesting data by id
dat_all <- DT.prep %>% group_by(snail) %>% nest()
View(dat_all)
#making the track
dat_all <- dat_all %>%
mutate(trk = map(data, function(d) {
amt::make_track(d, x, y, t, crs = sp::CRS("+init=epsg:32621"))
}))
#summary of track sampling rate for each individual
dat_all %>% mutate(sr = lapply(trk, summarize_sampling_rate)) %>%
dplyr::select(snail, sr) %>% unnest(cols = c(sr))
#### layers ####
# load proximity rasters
edge <- raster(paste0(raw, 'edgedist.tif'), )
brick <- raster(paste0(raw, 'brickedge1.tif'), )
#### making steps from track and extracting covariates ####
ssa <- dat_all %>%
mutate(steps = map(trk, function(x) {
x %>% amt::track_resample(rate = minutes(30), tolerance = minutes(10)) %>%
amt::filter_min_n_burst(min_n = 3) %>%
amt::steps_by_burst() %>% amt::random_steps(n=10) %>%
amt::extract_covariates(edge, where = "both")  %>%
amt::extract_covariates(edge, where = "both") %>% # both indicates you want the covariate at the start and end of the step
amt::time_of_day(t, where = 'start') %>%  # calc day/night ToD, only for start of the step
#you propbably won't need to do the land_start/_end renaming since you don't have any categorical rasters, but just in case some go on the brick, and you want to know if they're on the brick or not?
mutate( log_sl = log(sl_), # adding log transformed SL *DO THIS*
cos_ta = cos(ta_)) # adding cos transformed TA *DO THIS*
}))
#### making steps from track and extracting covariates ####
ssa <- dat_all %>%
mutate(steps = map(trk, function(x) {
x %>% amt::track_resample(rate = minutes(30), tolerance = minutes(10)) %>%
amt::filter_min_n_burst(min_n = 3) %>%
amt::steps_by_burst() %>% amt::random_steps(n=10) %>%
amt::extract_covariates(edge, where = "end")  %>%
amt::extract_covariates(edge, where = "end") %>% # both indicates you want the covariate at the start and end of the step
amt::time_of_day(t, where = 'start') %>%  # calc day/night ToD, only for start of the step
#you propbably won't need to do the land_start/_end renaming since you don't have any categorical rasters, but just in case some go on the brick, and you want to know if they're on the brick or not?
mutate( log_sl = log(sl_), # adding log transformed SL *DO THIS*
cos_ta = cos(ta_)) # adding cos transformed TA *DO THIS*
}))
#### making steps from track and extracting covariates ####
ssa <- dat_all %>%
mutate(steps = map(trk, function(x) {
x %>% amt::track_resample(rate = minutes(30), tolerance = minutes(10)) %>%
amt::filter_min_n_burst(min_n = 3) %>%
amt::steps_by_burst() %>% amt::random_steps(n=10) %>%
amt::extract_covariates(edge, where = "end")  %>%
amt::extract_covariates(brick, where = "end") %>% # both indicates you want the covariate at the start and end of the step
amt::time_of_day(t, where = 'start') %>%  # calc day/night ToD, only for start of the step
#you propbably won't need to do the land_start/_end renaming since you don't have any categorical rasters, but just in case some go on the brick, and you want to know if they're on the brick or not?
mutate( log_sl = log(sl_), # adding log transformed SL *DO THIS*
cos_ta = cos(ta_)) # adding cos transformed TA *DO THIS*
}))
#### making steps from track and extracting covariates ####
ssa <- dat_all %>%
mutate(steps = map(trk, function(x) {
x %>% amt::track_resample(rate = minutes(30), tolerance = minutes(10)) %>%
amt::filter_min_n_burst(min_n = 3) %>%
amt::steps_by_burst() %>% amt::random_steps(n=10) %>%
amt::extract_covariates(edge, where = "end")  %>%
#amt::extract_covariates(brick, where = "end") %>% # both indicates you want the covariate at the start and end of the step
amt::time_of_day(t, where = 'start') %>%  # calc day/night ToD, only for start of the step
#you propbably won't need to do the land_start/_end renaming since you don't have any categorical rasters, but just in case some go on the brick, and you want to know if they're on the brick or not?
mutate( log_sl = log(sl_), # adding log transformed SL *DO THIS*
cos_ta = cos(ta_)) # adding cos transformed TA *DO THIS*
}))
### Packages ----
libs <- c('data.table', 'dplyr', 'amt', 'raster', 'tidyr', 'ggplot2') # you might need lubridate
lapply(libs, require, character.only = TRUE)
### Input data ----
raw <- '~/Honours stuff/Snails/Data/raw/' # folder I store raw data here
derived <- '~/Honours stuff/Snails/Data/derived/' #this is the folder where I'll put my new data after I extract the covariates, as we'll be doing here
### data ----
dat <- fread(paste0(raw, 'UTMControlcsv.csv')) #my data
#'amt' needs a date time in this format with the date and time all in one
dat$datetime <- paste(dat$Date, dat$Time)
# making sure my newly created datetime is the right str
dat$datetime <- as.POSIXct(dat$datetime, tz = 'UTC', "%Y-%m-%d %H:%M")
### setting my crs ----
utm22T <- "+proj=utm +zone=22 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"
crs22 <- sp::CRS("+init=epsg:32621")
# selecting just the parts of the data that I need, you'll probably need to include your other things like temp and precip
DT.prep <- dat %>% dplyr::select(x = "xUTM", y = "yUTM", t = 'datetime', snail = 'Snail', temp = "Temperature", precip = "Precip")
# prepping structure for amt (they really like tidyvers, and it's kind of annoyingly dependent on it)
# nesting data by id
dat_all <- DT.prep %>% group_by(snail) %>% nest()
#making the track
dat_all <- dat_all %>%
mutate(trk = map(data, function(d) {
amt::make_track(d, x, y, t, crs = sp::CRS("+init=epsg:32621"))
}))
#summary of track sampling rate for each individual
dat_all %>% mutate(sr = lapply(trk, summarize_sampling_rate)) %>%
dplyr::select(snail, sr) %>% unnest(cols = c(sr))
#### layers ####
# load proximity rasters
edge <- raster(paste0(raw, 'edgedist.tif'), )
#plot(edge)
#### making steps from track and extracting covariates ####
ssa <- dat_all %>%
mutate(steps = map(trk, function(x) {
x %>% amt::track_resample(rate = minutes(30), tolerance = minutes(10)) %>%
amt::filter_min_n_burst(min_n = 3) %>%
amt::steps_by_burst() %>% amt::random_steps(n=10) %>%
amt::extract_covariates(edge, where = "both")  %>% # both indicates you want the covariate at the start and end of the step
amt::time_of_day(t, where = 'start') %>%  # calc day/night ToD, only for start of the step
#you propbably won't need to do the land_start/_end renaming since you don't have any categorical rasters, but just in case some go on the brick, and you want to know if they're on the brick or not?
mutate( log_sl = log(sl_), # adding log transformed SL *DO THIS*
cos_ta = cos(ta_)) # adding cos transformed TA *DO THIS*
}))
View(ssa)
# unnest the data
ssa.all <- ssa %>% dplyr::select(snail, steps) %>% unnest(cols = c(steps))
View(ssa.all)
# Save extracted data
saveRDS(ssa.all, '~/Honours stuff/Snails/Data/derived/ssaAll.Rds')#, overwrite=T)
### Packages ----
libs <- c('data.table', 'dplyr', 'amt', 'raster', 'tidyr', 'ggplot2') # you might need lubridate
lapply(libs, require, character.only = TRUE)
### Input data ----
raw <- '~/Honours stuff/Snails/Data/raw/' # folder I store raw data here
derived <- '~/Honours stuff/Snails/Data/derived/' #this is the folder where I'll put my new data after I extract the covariates, as we'll be doing here
### data ----
dat <- fread(paste0(raw, 'UTMTreat1.csv')) #my data
#'amt' needs a date time in this format with the date and time all in one
dat$datetime <- paste(dat$Date, dat$Time)
# making sure my newly created datetime is the right str
dat$datetime <- as.POSIXct(dat$datetime, tz = 'UTC', "%Y-%m-%d %H:%M")
### setting my crs ----
utm22T <- "+proj=utm +zone=22 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"
crs22 <- sp::CRS("+init=epsg:32621")
# selecting just the parts of the data that I need, you'll probably need to include your other things like temp and precip
DT.prep <- dat %>% dplyr::select(x = "xUTM", y = "yUTM", t = 'datetime', snail = 'Snail', temp = "Temperature", precip = "Precipitation")
View(DT.prep)
# prepping structure for amt (they really like tidyvers, and it's kind of annoyingly dependent on it)
# nesting data by id
dat_all <- DT.prep %>% group_by(snail) %>% nest()
#making the track
dat_all <- dat_all %>%
mutate(trk = map(data, function(d) {
amt::make_track(d, x, y, t, crs = sp::CRS("+init=epsg:32621"))
}))
#summary of track sampling rate for each individual
dat_all %>% mutate(sr = lapply(trk, summarize_sampling_rate)) %>%
dplyr::select(snail, sr) %>% unnest(cols = c(sr))
#### layers ####
# load proximity rasters
edge <- raster(paste0(raw, 'edgedist.tif'), )
brick <- raster(paste0(raw, 'brickedge1.tif'), )
#### making steps from track and extracting covariates ####
ssa <- dat_all %>%
mutate(steps = map(trk, function(x) {
x %>% amt::track_resample(rate = minutes(30), tolerance = minutes(10)) %>%
amt::filter_min_n_burst(min_n = 3) %>%
amt::steps_by_burst() %>% amt::random_steps(n=10) %>%
amt::extract_covariates(edge, where = "end")  %>%
#amt::extract_covariates(brick, where = "end") %>% # both indicates you want the covariate at the start and end of the step
amt::time_of_day(t, where = 'start') %>%  # calc day/night ToD, only for start of the step
#you propbably won't need to do the land_start/_end renaming since you don't have any categorical rasters, but just in case some go on the brick, and you want to know if they're on the brick or not?
mutate( log_sl = log(sl_), # adding log transformed SL *DO THIS*
cos_ta = cos(ta_)) # adding cos transformed TA *DO THIS*
}))
#### making steps from track and extracting covariates ####
ssa <- dat_all %>%
mutate(steps = map(trk, function(x) {
x %>% amt::track_resample(rate = minutes(30), tolerance = minutes(10)) %>%
amt::filter_min_n_burst(min_n = 3) %>%
amt::steps_by_burst() %>% amt::random_steps(n=10) %>%
amt::extract_covariates(edge, where = "end")  %>%
amt::extract_covariates(brick, where = "end") %>% # both indicates you want the covariate at the start and end of the step
amt::time_of_day(t, where = 'start') %>%  # calc day/night ToD, only for start of the step
#you propbably won't need to do the land_start/_end renaming since you don't have any categorical rasters, but just in case some go on the brick, and you want to know if they're on the brick or not?
mutate( log_sl = log(sl_), # adding log transformed SL *DO THIS*
cos_ta = cos(ta_)) # adding cos transformed TA *DO THIS*
}))
#### making steps from track and extracting covariates ####
ssa <- dat_all %>%
mutate(steps = map(trk, function(x) {
x %>% amt::track_resample(rate = minutes(30), tolerance = minutes(10)) %>%
amt::filter_min_n_burst(min_n = 3) %>%
amt::steps_by_burst() %>% amt::random_steps(n=10) %>%
amt::extract_covariates(edge, where = "end")  %>%
amt::extract_covariates(brick, where = "end") %>% # both indicates you want the covariate at the start and end of the step
amt::time_of_day(t, where = 'start') %>%  # calc day/night ToD, only for start of the step
#you propbably won't need to do the land_start/_end renaming since you don't have any categorical rasters, but just in case some go on the brick, and you want to know if they're on the brick or not?
mutate( log_sl = log(sl_), # adding log transformed SL *DO THIS*
cos_ta = cos(ta_)) # adding cos transformed TA *DO THIS*
}))
#### making steps from track and extracting covariates ####
ssa <- dat_all %>%
mutate(steps = map(trk, function(x) {
x %>% amt::track_resample(rate = minutes(30), tolerance = minutes(10)) %>%
amt::filter_min_n_burst(min_n = 3) %>%
amt::steps_by_burst() %>% amt::random_steps(n=10) %>%
amt::extract_covariates(edge, where = "end")  %>%
amt::extract_covariates(brick, where = "end") %>% # both indicates you want the covariate at the start and end of the step
amt::time_of_day(t, where = 'start') %>%  # calc day/night ToD, only for start of the step
#you propbably won't need to do the land_start/_end renaming since you don't have any categorical rasters, but just in case some go on the brick, and you want to know if they're on the brick or not?
mutate( log_sl = log(sl_), # adding log transformed SL *DO THIS*
cos_ta = cos(ta_)) # adding cos transformed TA *DO THIS*
}))
#### making steps from track and extracting covariates ####
ssa <- dat_all %>%
mutate(steps = map(trk, function(x) {
x %>% amt::track_resample(rate = minutes(30), tolerance = minutes(10)) %>%
amt::filter_min_n_burst(min_n = 3) %>%
amt::steps_by_burst() %>% amt::random_steps(n=10) %>%
amt::extract_covariates(edge, where = "end")  %>%
amt::extract_covariates(brick, where = "end") %>% # both indicates you want the covariate at the start and end of the step
amt::time_of_day(t, where = 'start') %>%  # calc day/night ToD, only for start of the step
#you propbably won't need to do the land_start/_end renaming since you don't have any categorical rasters, but just in case some go on the brick, and you want to know if they're on the brick or not?
mutate( log_sl = log(sl_), # adding log transformed SL *DO THIS*
cos_ta = cos(ta_)) # adding cos transformed TA *DO THIS*
}))
#### making steps from track and extracting covariates ####
ssa <- dat_all %>%
mutate(steps = map(trk, function(x) {
x %>% amt::track_resample(rate = minutes(30), tolerance = minutes(10)) %>%
amt::filter_min_n_burst(min_n = 3) %>%
amt::steps_by_burst() %>% amt::random_steps(n=10) %>%
amt::extract_covariates(edge, where = "end")  %>%
amt::extract_covariates(brick, where = "end") %>% # both indicates you want the covariate at the start and end of the step
amt::time_of_day(t, where = 'start') %>%  # calc day/night ToD, only for start of the step
#you propbably won't need to do the land_start/_end renaming since you don't have any categorical rasters, but just in case some go on the brick, and you want to know if they're on the brick or not?
mutate( log_sl = log(sl_), # adding log transformed SL *DO THIS*
cos_ta = cos(ta_)) # adding cos transformed TA *DO THIS*
}))
