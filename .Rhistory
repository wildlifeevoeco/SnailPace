amt::extract_covariates(edge, where = "end")  %>%
amt::extract_covariates(brick, where = "end") %>% # both indicates you want the covariate at the start and end of the step
amt::time_of_day(t, where = 'start') %>%  # calc day/night ToD, only for start of the step
#you propbably won't need to do the land_start/_end renaming since you don't have any categorical rasters, but just in case some go on the brick, and you want to know if they're on the brick or not?
mutate( log_sl = log(sl_), # adding log transformed SL *DO THIS*
cos_ta = cos(ta_)) # adding cos transformed TA *DO THIS*
}))
#### making steps from track and extracting covariates ####
ssa <- dat_all %>%
mutate(steps = map(trk, function(x) {
x %>% amt::track_resample(rate = minutes(30), tolerance = minutes(10)) %>%
amt::filter_min_n_burst(min_n = 3) %>%
amt::steps_by_burst() %>% amt::random_steps(n=10) %>%
amt::extract_covariates(edge, where = "end")  %>%
amt::extract_covariates(brick, where = "end") %>% # both indicates you want the covariate at the start and end of the step
amt::time_of_day(t, where = 'start') %>%  # calc day/night ToD, only for start of the step
#you propbably won't need to do the land_start/_end renaming since you don't have any categorical rasters, but just in case some go on the brick, and you want to know if they're on the brick or not?
mutate( log_sl = log(sl_), # adding log transformed SL *DO THIS*
cos_ta = cos(ta_)) # adding cos transformed TA *DO THIS*
}))
library(lubridate)
### Packages ----
libs <- c('data.table', 'dplyr', 'amt', 'raster', 'tidyr', 'ggplot2') # you might need lubridate
lapply(libs, require, character.only = TRUE)
### Input data ----
raw <- '~/Honours stuff/Snails/Data/raw/' # folder I store raw data here
derived <- '~/Honours stuff/Snails/Data/derived/' #this is the folder where I'll put my new data after I extract the covariates, as we'll be doing here
### data ----
dat <- fread(paste0(raw, 'SnailDataUTM.csv')) #my data
#'amt' needs a date time in this format with the date and time all in one
dat$datetime <- paste(dat$Date, dat$Time)
# making sure my newly created datetime is the right str
dat$datetime <- as.POSIXct(dat$datetime, tz = 'UTC', "%Y-%m-%d %H:%M")
### setting my crs ----
utm22T <- "+proj=utm +zone=22 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"
crs22 <- sp::CRS("+init=epsg:32621")
# selecting just the parts of the data that I need, you'll probably need to include your other things like temp and precip
DT.prep <- dat %>% dplyr::select(x = "xUTM", y = "yUTM", t = 'datetime', snail = 'Snail', temp = "Temperature", precip = "Precipitation", treatment = "Treatment", stage = "Stage")
# prepping structure for amt (they really like tidyvers, and it's kind of annoyingly dependent on it)
# nesting data by id
dat_all <- DT.prep %>% group_by(snail) %>% nest()
#making the track
dat_all <- dat_all %>%
mutate(trk = map(data, function(d) {
amt::make_track(d, x, y, t, crs = sp::CRS("+init=epsg:32621"))
}))
#summary of track sampling rate for each individual
dat_all %>% mutate(sr = lapply(trk, summarize_sampling_rate)) %>%
dplyr::select(snail, sr) %>% unnest(cols = c(sr))
dat_all <- setDT(dat_all)
#### layers ####
# load proximity rasters
edge <- raster(paste0(raw, 'edgedist.tif'), )
brickedge1 <- raster(paste0(raw, 'brickedge1.tif'), )
brickedge2 <- raster(paste0(raw, 'brickedge2.tif'), )
brickedge3 <- raster(paste0(raw, 'brickedge3.tif'), )
#### making steps from track and extracting covariates ####
ssa <- dat_all %>%
mutate(steps = map(trk, function(x) {
x %>% amt::track_resample(rate = minutes(30), tolerance = minutes(10)) %>%
amt::filter_min_n_burst(min_n = 3) %>%
amt::steps_by_burst() %>% amt::random_steps(n=10) %>%
amt::extract_covariates(edge, where = "both")  %>% # both indicates you want the covariate at the start and end of the step
amt::extract_covariates(brickedge1, where = "both") %>%
amt::extract_covariates(brickedge2, where = "both") %>%
amt::extract_covariates(brickedge3, where = "both") %>%
amt::time_of_day(t, where = 'start') %>%  # calc day/night ToD, only for start of the step
#you propbably won't need to do the land_start/_end renaming since you don't have any categorical rasters, but just in case some go on the brick, and you want to know if they're on the brick or not?
mutate( log_sl = log(sl_), # adding log transformed SL *DO THIS*
cos_ta = cos(ta_)) # adding cos transformed TA *DO THIS*
}))
View(dat_all)
View(dat_all[[2]][[1]])
View(dat_all[[3]][[1]])
View(DT.prep)
dat_all <- setDT(dat_all)
View(dat_all)
View(dat_all[[3]][[1]])
#### making steps from track and extracting covariates ####
ssa <- dat_all %>%
mutate(steps = map(trk, function(x) {
x %>% amt::track_resample(rate = minutes(30), tolerance = minutes(10)) %>%
amt::filter_min_n_burst(min_n = 3) %>%
amt::steps_by_burst() %>% amt::random_steps(n=10) %>%
amt::extract_covariates(edge, where = "both")  %>% # both indicates you want the covariate at the start and end of the step
amt::extract_covariates(brickedge1, where = "both") %>%
amt::extract_covariates(brickedge2, where = "both") %>%
amt::extract_covariates(brickedge3, where = "both") %>%
amt::time_of_day(t_, where = 'start') %>%  # calc day/night ToD, only for start of the step
#you propbably won't need to do the land_start/_end renaming since you don't have any categorical rasters, but just in case some go on the brick, and you want to know if they're on the brick or not?
mutate( log_sl = log(sl_), # adding log transformed SL *DO THIS*
cos_ta = cos(ta_)) # adding cos transformed TA *DO THIS*
}))
#### making steps from track and extracting covariates ####
ssa <- dat_all %>%
mutate(steps = map(trk, function(x) {
x %>% amt::track_resample(rate = minutes(30), tolerance = minutes(10)) %>%
amt::filter_min_n_burst(min_n = 3) %>%
amt::steps_by_burst() %>% amt::random_steps(n=10) %>%
amt::extract_covariates(edge, where = "both")  %>% # both indicates you want the covariate at the start and end of the step
amt::extract_covariates(brickedge1, where = "both") %>%
amt::extract_covariates(brickedge2, where = "both") %>%
amt::extract_covariates(brickedge3, where = "both") %>%
amt::time_of_day(t, where = 'start') %>%  # calc day/night ToD, only for start of the step
#you propbably won't need to do the land_start/_end renaming since you don't have any categorical rasters, but just in case some go on the brick, and you want to know if they're on the brick or not?
mutate( log_sl = log(sl_), # adding log transformed SL *DO THIS*
cos_ta = cos(ta_)) # adding cos transformed TA *DO THIS*
}))
#### making steps from track and extracting covariates ####
ssa <- dat_all %>%
mutate(steps = map(trk, function(x) {
x %>% amt::track_resample(rate = minutes(30), tolerance = minutes(10)) %>%
amt::filter_min_n_burst(min_n = 3) %>%
amt::steps_by_burst() %>% amt::random_steps(n=10) %>%
amt::extract_covariates(edge, where = "both")  %>% # both indicates you want the covariate at the start and end of the step
amt::extract_covariates(brickedge1, where = "both") %>%
amt::extract_covariates(brickedge2, where = "both") %>%
amt::extract_covariates(brickedge3, where = "both") %>%
amt::time_of_day(t, where = 'start') %>%  # calc day/night ToD, only for start of the step
#mutate( log_sl = log(sl_), # adding log transformed SL *DO THIS*
#       cos_ta = cos(ta_)) # adding cos transformed TA *DO THIS*
}))
#### making steps from track and extracting covariates ####
ssa <- dat_all %>%
mutate(steps = map(trk, function(x) {
x %>% amt::track_resample(rate = minutes(30), tolerance = minutes(10)) %>%
amt::filter_min_n_burst(min_n = 3) %>%
amt::steps_by_burst() %>% amt::random_steps(n=10) %>%
amt::extract_covariates(edge, where = "both")  %>% # both indicates you want the covariate at the start and end of the step
amt::extract_covariates(brickedge1, where = "both") %>%
amt::extract_covariates(brickedge2, where = "both") %>%
amt::extract_covariates(brickedge3, where = "both") %>%
amt::time_of_day(t, where = 'start')# %>%  # calc day/night ToD, only for start of the step
#mutate( log_sl = log(sl_), # adding log transformed SL *DO THIS*
#       cos_ta = cos(ta_)) # adding cos transformed TA *DO THIS*
}))
#### making steps from track and extracting covariates ####
ssa <- dat_all %>%
mutate(steps = map(trk, function(x) {
x %>% amt::track_resample(rate = minutes(30), tolerance = minutes(10)) %>%
amt::filter_min_n_burst(min_n = 3) %>%
amt::steps_by_burst() %>% amt::random_steps(n=10) %>%
# amt::extract_covariates(edge, where = "both")  %>% # both indicates you want the covariate at the start and end of the step
#amt::extract_covariates(brickedge1, where = "both") %>%
#amt::extract_covariates(brickedge2, where = "both") %>%
#amt::extract_covariates(brickedge3, where = "both") %>%
amt::time_of_day(t, where = 'start') %>%  # calc day/night ToD, only for start of the step
mutate( log_sl = log(sl_), # adding log transformed SL *DO THIS*
cos_ta = cos(ta_)) # adding cos transformed TA *DO THIS*
}))
x %>% amt::track_resample(rate = minutes(30), tolerance = minutes(10)) %>%
amt::filter_min_n_burst(min_n = 3) %>%
amt::steps_by_burst() %>% amt::random_steps(n=10) %>%
# amt::extract_covariates(edge, where = "both")  %>% # both indicates you want the covariate at the start and end of the step
#amt::extract_covariates(brickedge1, where = "both") %>%
#amt::extract_covariates(brickedge2, where = "both") %>%
#amt::extract_covariates(brickedge3, where = "both") %>%
#  amt::time_of_day(t, where = 'start') %>%  # calc day/night ToD, only for start of the step
mutate( log_sl = log(sl_), # adding log transformed SL *DO THIS*
cos_ta = cos(ta_)) # adding cos transformed TA *DO THIS*
#### making steps from track and extracting covariates ####
ssa <- dat_all %>%
mutate(steps = map(trk, function(x) {
x %>% amt::track_resample(rate = minutes(30), tolerance = minutes(10)) %>%
amt::filter_min_n_burst(min_n = 3) %>%
amt::steps_by_burst() %>% amt::random_steps(n=10) %>%
# amt::extract_covariates(edge, where = "both")  %>% # both indicates you want the covariate at the start and end of the step
#amt::extract_covariates(brickedge1, where = "both") %>%
#amt::extract_covariates(brickedge2, where = "both") %>%
#amt::extract_covariates(brickedge3, where = "both") %>%
#  amt::time_of_day(t, where = 'start') %>%  # calc day/night ToD, only for start of the step
mutate( log_sl = log(sl_), # adding log transformed SL *DO THIS*
cos_ta = cos(ta_)) # adding cos transformed TA *DO THIS*
}))
#### making steps from track and extracting covariates ####
ssa <- dat_all %>%
mutate(steps = map(trk, function(x) {
x %>% amt::track_resample(rate = minutes(30), tolerance = minutes(10)) %>%
amt::filter_min_n_burst(min_n = 3) %>%
amt::steps_by_burst() %>% amt::random_steps(n=10) #%>%
# amt::extract_covariates(edge, where = "both")  %>% # both indicates you want the covariate at the start and end of the step
#amt::extract_covariates(brickedge1, where = "both") %>%
#amt::extract_covariates(brickedge2, where = "both") %>%
#amt::extract_covariates(brickedge3, where = "both") %>%
#  amt::time_of_day(t, where = 'start') %>%  # calc day/night ToD, only for start of the step
# mutate( log_sl = log(sl_), # adding log transformed SL *DO THIS*
#           cos_ta = cos(ta_)) # adding cos transformed TA *DO THIS*
}))
x %>% amt::track_resample(rate = minutes(30), tolerance = minutes(10)) %>%
amt::filter_min_n_burst(min_n = 3) #%>%
#### making steps from track and extracting covariates ####
ssa <- dat_all %>%
mutate(steps = map(trk, function(x) {
x %>% amt::track_resample(rate = minutes(30), tolerance = minutes(10)) %>%
amt::filter_min_n_burst(min_n = 3) #%>%
#  amt::steps_by_burst() %>% amt::random_steps(n=10) #%>%
# amt::extract_covariates(edge, where = "both")  %>% # both indicates you want the covariate at the start and end of the step
#amt::extract_covariates(brickedge1, where = "both") %>%
#amt::extract_covariates(brickedge2, where = "both") %>%
#amt::extract_covariates(brickedge3, where = "both") %>%
#  amt::time_of_day(t, where = 'start') %>%  # calc day/night ToD, only for start of the step
# mutate( log_sl = log(sl_), # adding log transformed SL *DO THIS*
#           cos_ta = cos(ta_)) # adding cos transformed TA *DO THIS*
}))
#### making steps from track and extracting covariates ####
ssa <- dat_all %>%
mutate(steps = map(trk, function(x) {
x %>% amt::track_resample(rate = minutes(30), tolerance = minutes(10)) %>%
amt::filter_min_n_burst(min_n = 3) #%>%
amt::steps_by_burst() %>% amt::random_steps(10) %>% ###ERROR HERE
amt::extract_covariates(edge, where = "both")  %>% # both indicates you want the covariate at the start and end of the step
amt::extract_covariates(brickedge1, where = "both") %>%
amt::extract_covariates(brickedge2, where = "both") %>%
amt::extract_covariates(brickedge3, where = "both") %>%
amt::time_of_day(t, where = 'start') %>%  # calc day/night ToD, only for start of the step
mutate( log_sl = log(sl_), # adding log transformed SL *DO THIS*
cos_ta = cos(ta_)) # adding cos transformed TA *DO THIS*
}))
#### making steps from track and extracting covariates ####
ssa <- dat_all %>%
mutate(steps = map(trk, function(x) {
x %>% amt::track_resample(rate = minutes(30), tolerance = minutes(10)) %>%
amt::filter_min_n_burst(min_n = 3) #%>%
amt::steps_by_burst(1) %>% amt::random_steps(10) %>% ###ERROR HERE
amt::extract_covariates(edge, where = "both")  %>% # both indicates you want the covariate at the start and end of the step
amt::extract_covariates(brickedge1, where = "both") %>%
amt::extract_covariates(brickedge2, where = "both") %>%
amt::extract_covariates(brickedge3, where = "both") %>%
amt::time_of_day(t, where = 'start') %>%  # calc day/night ToD, only for start of the step
mutate( log_sl = log(sl_), # adding log transformed SL *DO THIS*
cos_ta = cos(ta_)) # adding cos transformed TA *DO THIS*
}))
#### making steps from track and extracting covariates ####
ssa <- dat_all %>%
mutate(steps = map(trk, function(x) {
x %>% amt::track_resample(rate = minutes(30), tolerance = minutes(10)) %>%
amt::filter_min_n_burst(min_n = 3) #%>%
amt::steps_by_burst(NULL) %>% amt::random_steps(10) %>% ###ERROR HERE
amt::extract_covariates(edge, where = "both")  %>% # both indicates you want the covariate at the start and end of the step
amt::extract_covariates(brickedge1, where = "both") %>%
amt::extract_covariates(brickedge2, where = "both") %>%
amt::extract_covariates(brickedge3, where = "both") %>%
amt::time_of_day(t, where = 'start') %>%  # calc day/night ToD, only for start of the step
mutate( log_sl = log(sl_), # adding log transformed SL *DO THIS*
cos_ta = cos(ta_)) # adding cos transformed TA *DO THIS*
}))
#### making steps from track and extracting covariates ####
ssa <- dat_all %>%
mutate(steps = map(trk, function(x) {
x %>% amt::track_resample(rate = minutes(30), tolerance = minutes(10)) %>%
amt::filter_min_n_burst(min_n = 3) #%>%
amt::steps_by_burst(x) %>% amt::random_steps(n=10) %>% ###ERROR HERE
amt::extract_covariates(edge, where = "both")  %>% # both indicates you want the covariate at the start and end of the step
amt::extract_covariates(brickedge1, where = "both") %>%
amt::extract_covariates(brickedge2, where = "both") %>%
amt::extract_covariates(brickedge3, where = "both") %>%
amt::time_of_day(t, where = 'start') %>%  # calc day/night ToD, only for start of the step
mutate( log_sl = log(sl_), # adding log transformed SL *DO THIS*
cos_ta = cos(ta_)) # adding cos transformed TA *DO THIS*
}))
#### making steps from track and extracting covariates ####
ssa <- dat_all %>%
mutate(steps = map(trk, function(x) {
x %>% amt::track_resample(rate = minutes(30), tolerance = minutes(10)) %>%
amt::filter_min_n_burst(min_n = 3) #%>%
amt::steps_by_burst() %>% amt::random_steps(n=10) %>% ###ERROR HERE
amt::extract_covariates(edge, where = "both")  %>% # both indicates you want the covariate at the start and end of the step
amt::extract_covariates(brickedge1, where = "both") %>%
amt::extract_covariates(brickedge2, where = "both") %>%
amt::extract_covariates(brickedge3, where = "both") %>%
amt::time_of_day(t, where = 'start') %>%  # calc day/night ToD, only for start of the step
mutate( log_sl = log(sl_), # adding log transformed SL *DO THIS*
cos_ta = cos(ta_)) # adding cos transformed TA *DO THIS*
}))
#### making steps from track and extracting covariates ####
ssa <- dat_all %>%
mutate(steps = map(trk, function(x) {
x %>% amt::track_resample(rate = minutes(30), tolerance = minutes(10)) %>%
amt::filter_min_n_burst(min_n = 3) #%>%
amt::steps_by_burst(trk) %>% amt::random_steps(n=10) %>% ###ERROR HERE
amt::extract_covariates(edge, where = "both")  %>% # both indicates you want the covariate at the start and end of the step
amt::extract_covariates(brickedge1, where = "both") %>%
amt::extract_covariates(brickedge2, where = "both") %>%
amt::extract_covariates(brickedge3, where = "both") %>%
amt::time_of_day(t, where = 'start') %>%  # calc day/night ToD, only for start of the step
mutate( log_sl = log(sl_), # adding log transformed SL *DO THIS*
cos_ta = cos(ta_)) # adding cos transformed TA *DO THIS*
}))
#### making steps from track and extracting covariates ####
ssa <- dat_all %>%
mutate(steps = map(trk, function(x) {
x %>% amt::track_resample(rate = minutes(30), tolerance = minutes(10)) %>%
amt::filter_min_n_burst(min_n = 3) #%>%
amt::steps_by_burst() %>% amt::random_steps(n=10) %>% ###ERROR HERE
amt::extract_covariates(edge, where = "both")  %>% # both indicates you want the covariate at the start and end of the step
amt::extract_covariates(brickedge1, where = "both") %>%
amt::extract_covariates(brickedge2, where = "both") %>%
amt::extract_covariates(brickedge3, where = "both") %>%
amt::time_of_day(t, where = 'start') %>%  # calc day/night ToD, only for start of the step
mutate( log_sl = log(sl_), # adding log transformed SL *DO THIS*
cos_ta = cos(ta_)) # adding cos transformed TA *DO THIS*
}))
#### making steps from track and extracting covariates ####
ssa <- dat_all %>%
mutate(steps = map(trk, function(x) {
x %>% amt::track_resample(rate = minutes(30), tolerance = minutes(10)) %>%
amt::filter_min_n_burst(min_n = 3) #%>%
amt::steps_by_burst() %>% amt::random_steps(n=10) %>% ###ERROR HERE
amt::extract_covariates(edge, where = "both")  %>% # both indicates you want the covariate at the start and end of the step
amt::extract_covariates(brickedge1, where = "both") %>%
amt::extract_covariates(brickedge2, where = "both") %>%
amt::extract_covariates(brickedge3, where = "both") %>%
amt::time_of_day(t, where = 'start') %>%  # calc day/night ToD, only for start of the step
mutate( log_sl = log(sl_), # adding log transformed SL *DO THIS*
cos_ta = cos(ta_)) # adding cos transformed TA *DO THIS*
}))
View(ssa)
View(ssa[[4]][[1]])
# unnest the data
ssa.all <- ssa %>% dplyr::select(snail, steps) %>% unnest(cols = c(steps))
View(ssa.all)
#### making steps from track and extracting covariates ####
ssa <- dat_all %>%
mutate(steps = map(trk, function(x) {
x %>% amt::track_resample(rate = minutes(30), tolerance = minutes(10)) %>%
amt::filter_min_n_burst(min_n = 3) #%>%
amt::steps_by_burst() %>% amt::random_steps(n=10) %>% ###ERROR HERE
amt::extract_covariates(edge, where = "both")  %>% # both indicates you want the covariate at the start and end of the step
amt::extract_covariates(brickedge1, where = "both") %>%
amt::extract_covariates(brickedge2, where = "both") %>%
amt::extract_covariates(brickedge3, where = "both") %>%
amt::time_of_day(t, where = 'start') %>%  # calc day/night ToD, only for start of the step
mutate( log_sl = log(sl_), # adding log transformed SL *DO THIS*
cos_ta = cos(ta_)) # adding cos transformed TA *DO THIS*
}))
### Packages ----
libs <- c('data.table', 'dplyr', 'amt', 'raster', 'tidyr', 'ggplot2') # you might need lubridate
lapply(libs, require, character.only = TRUE)
### Input data ----
raw <- '~/Honours stuff/Snails/Data/raw/' # folder I store raw data here
derived <- '~/Honours stuff/Snails/Data/derived/' #this is the folder where I'll put my new data after I extract the covariates, as we'll be doing here
### data ----
dat <- fread(paste0(raw, 'SnailDataUTM.csv')) #my data
#'amt' needs a date time in this format with the date and time all in one
dat$datetime <- paste(dat$Date, dat$Time)
# making sure my newly created datetime is the right str
dat$datetime <- as.POSIXct(dat$datetime, tz = 'UTC', "%Y-%m-%d %H:%M")
### setting my crs ----
utm22T <- "+proj=utm +zone=22 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"
crs22 <- sp::CRS("+init=epsg:32621")
# selecting just the parts of the data that I need, you'll probably need to include your other things like temp and precip
DT.prep <- dat %>% dplyr::select(x = "xUTM", y = "yUTM", t = 'datetime', snail = 'Snail', temp = "Temperature", precip = "Precipitation", treatment = "Treatment", stage = "Stage")
# prepping structure for amt (they really like tidyvers, and it's kind of annoyingly dependent on it)
# nesting data by id
dat_all <- DT.prep %>% group_by(snail) %>% nest()
#making the track
dat_all <- dat_all %>%
mutate(trk = map(data, function(d) {
amt::make_track(d, x, y, t, crs = sp::CRS("+init=epsg:32621"))
}))
View(dat_all)
#### layers ####
# load proximity rasters
edge <- raster(paste0(raw, 'edgedist.tif'), )
brickedge1 <- raster(paste0(raw, 'brickedge1.tif'), )
brickedge2 <- raster(paste0(raw, 'brickedge2.tif'), )
brickedge3 <- raster(paste0(raw, 'brickedge3.tif'), )
#### making steps from track and extracting covariates ####
ssa <- dat_all %>%
mutate(steps = map(trk, function(x) {
x %>% amt::track_resample(rate = minutes(30), tolerance = minutes(10)) %>%
amt::filter_min_n_burst(min_n = 3) #%>%
amt::steps_by_burst() %>% amt::random_steps(n=10) %>% ###ERROR HERE
amt::extract_covariates(edge, where = "both")  %>% # both indicates you want the covariate at the start and end of the step
amt::extract_covariates(brickedge1, where = "both") %>%
amt::extract_covariates(brickedge2, where = "both") %>%
amt::extract_covariates(brickedge3, where = "both") %>%
amt::time_of_day(t, where = 'start') %>%  # calc day/night ToD, only for start of the step
mutate( log_sl = log(sl_), # adding log transformed SL *DO THIS*
cos_ta = cos(ta_)) # adding cos transformed TA *DO THIS*
}))
#summary of track sampling rate for each individual
dat_all %>% mutate(sr = lapply(trk, summarize_sampling_rate)) %>%
dplyr::select(snail, sr) %>% unnest(cols = c(sr))
#### layers ####
# load proximity rasters
edge <- raster(paste0(raw, 'edgedist.tif'), )
brickedge1 <- raster(paste0(raw, 'brickedge1.tif'), )
brickedge2 <- raster(paste0(raw, 'brickedge2.tif'), )
brickedge3 <- raster(paste0(raw, 'brickedge3.tif'), )
#### making steps from track and extracting covariates ####
ssa <- dat_all %>%
mutate(steps = map(trk, function(x) {
x %>% amt::track_resample(rate = minutes(30), tolerance = minutes(10)) %>%
amt::filter_min_n_burst(min_n = 3) #%>%
amt::steps_by_burst() %>% amt::random_steps(n=10) %>% ###ERROR HERE
amt::extract_covariates(edge, where = "both")  %>% # both indicates you want the covariate at the start and end of the step
amt::extract_covariates(brickedge1, where = "both") %>%
amt::extract_covariates(brickedge2, where = "both") %>%
amt::extract_covariates(brickedge3, where = "both") %>%
amt::time_of_day(t, where = 'start') %>%  # calc day/night ToD, only for start of the step
mutate( log_sl = log(sl_), # adding log transformed SL *DO THIS*
cos_ta = cos(ta_)) # adding cos transformed TA *DO THIS*
}))
# unnest the data
ssa.all <- ssa %>% dplyr::select(snail, steps) %>% unnest(cols = c(steps))
str(trk)
str(dat_all$trk)
### Packages ----
libs <- c('data.table', 'dplyr', 'amt', 'raster', 'tidyr', 'ggplot2') # you might need lubridate
lapply(libs, require, character.only = TRUE)
### Input data ----
raw <- '~/Honours stuff/Snails/Data/raw/' # folder I store raw data here
derived <- '~/Honours stuff/Snails/Data/derived/' #this is the folder where I'll put my new data after I extract the covariates, as we'll be doing here
### data ----
dat <- fread(paste0(raw, 'SnailDataUTM.csv')) #my data
#'amt' needs a date time in this format with the date and time all in one
dat$datetime <- paste(dat$Date, dat$Time)
# making sure my newly created datetime is the right str
dat$datetime <- as.POSIXct(dat$datetime, tz = 'UTC', "%Y-%m-%d %H:%M")
### setting my crs ----
utm22T <- "+proj=utm +zone=22 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"
crs22 <- sp::CRS("+init=epsg:32621")
# selecting just the parts of the data that I need, you'll probably need to include your other things like temp and precip
DT.prep <- dat %>% dplyr::select(x = "xUTM", y = "yUTM", t = 'datetime', snail = 'Snail', temp = "Temperature", precip = "Precipitation", treatment = "Treatment", stage = "Stage")
# prepping structure for amt (they really like tidyvers, and it's kind of annoyingly dependent on it)
# nesting data by id
dat_all <- DT.prep %>% group_by(snail) %>% nest()
#making the track
dat_all <- dat_all %>%
mutate(trk = map(data, function(d) {
amt::make_track(d, x, y, t, crs = sp::CRS("+init=epsg:32621"))
}))
#summary of track sampling rate for each individual
dat_all %>% mutate(sr = lapply(trk, summarize_sampling_rate)) %>%
dplyr::select(snail, sr) %>% unnest(cols = c(sr))
#### layers ####
# load proximity rasters
edge <- raster(paste0(raw, 'edgedist.tif'), )
brickedge1 <- raster(paste0(raw, 'brickedge1.tif'), )
brickedge2 <- raster(paste0(raw, 'brickedge2.tif'), )
brickedge3 <- raster(paste0(raw, 'brickedge3.tif'), )
#### making steps from track and extracting covariates ####
ssa <- dat_all %>%
mutate(steps = map(trk, function(x) {
x %>% amt::track_resample(rate = minutes(30), tolerance = minutes(10)) %>%
amt::filter_min_n_burst(min_n = 3) #%>%
amt::steps_by_burst() %>% amt::random_steps(n=10) %>% ###ERROR HERE
amt::extract_covariates(edge, where = "both")  %>% # both indicates you want the covariate at the start and end of the step
amt::extract_covariates(brickedge1, where = "both") %>%
amt::extract_covariates(brickedge2, where = "both") %>%
amt::extract_covariates(brickedge3, where = "both") %>%
amt::time_of_day(t, where = 'start') %>%  # calc day/night ToD, only for start of the step
mutate( log_sl = log(sl_), # adding log transformed SL *DO THIS*
cos_ta = cos(ta_)) # adding cos transformed TA *DO THIS*
}))
### Packages ----
libs <- c('data.table', 'dplyr', 'amt', 'raster', 'tidyr', 'ggplot2') # you might need lubridate
lapply(libs, require, character.only = TRUE)
### Input data ----
raw <- '~/Honours stuff/Snails/Data/raw/' # folder I store raw data here
derived <- '~/Honours stuff/Snails/Data/derived/' #this is the folder where I'll put my new data after I extract the covariates, as we'll be doing here
### data ----
dat <- fread(paste0(raw, 'SnailDataUTM.csv')) #my data
#'amt' needs a date time in this format with the date and time all in one
dat$datetime <- paste(dat$Date, dat$Time)
# making sure my newly created datetime is the right str
dat$datetime <- as.POSIXct(dat$datetime, tz = 'UTC', "%Y-%m-%d %H:%M")
### setting my crs ----
utm22T <- "+proj=utm +zone=22 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"
crs22 <- sp::CRS("+init=epsg:32621")
# selecting just the parts of the data that I need, you'll probably need to include your other things like temp and precip
DT.prep <- dat %>% dplyr::select(x = "xUTM", y = "yUTM", t = 'datetime', snail = 'Snail', temp = "Temperature", precip = "Precipitation", treatment = "Treatment", stage = "Stage")
# prepping structure for amt (they really like tidyvers, and it's kind of annoyingly dependent on it)
# nesting data by id
dat_all <- DT.prep %>% group_by(snail) %>% nest()
#making the track
dat_all <- dat_all %>%
mutate(trk = map(data, function(d) {
amt::make_track(d, x, y, t, crs = sp::CRS("+init=epsg:32621"))
}))
#summary of track sampling rate for each individual
dat_all %>% mutate(sr = lapply(trk, summarize_sampling_rate)) %>%
dplyr::select(snail, sr) %>% unnest(cols = c(sr))
#### layers ####
# load proximity rasters
edge <- raster(paste0(raw, 'edgedist.tif'), )
brickedge1 <- raster(paste0(raw, 'brickedge1.tif'), )
brickedge2 <- raster(paste0(raw, 'brickedge2.tif'), )
brickedge3 <- raster(paste0(raw, 'brickedge3.tif'), )
#### making steps from track and extracting covariates ####
ssa <- dat_all %>%
mutate(steps = map(trk, function(x) {
x %>% amt::track_resample(rate = minutes(30), tolerance = minutes(10)) %>%
amt::filter_min_n_burst(min_n = 3) #%>%
amt::steps_by_burst() %>% amt::random_steps(n=10) %>% ###ERROR HERE
amt::extract_covariates(edge, where = "both")  %>% # both indicates you want the covariate at the start and end of the step
amt::extract_covariates(brickedge1, where = "both") %>%
amt::extract_covariates(brickedge2, where = "both") %>%
amt::extract_covariates(brickedge3, where = "both") %>%
amt::time_of_day(t, where = 'start') %>%  # calc day/night ToD, only for start of the step
mutate( log_sl = log(sl_), # adding log transformed SL *DO THIS*
cos_ta = cos(ta_)) # adding cos transformed TA *DO THIS*
}))
#summary of track sampling rate for each individual
dat_all -> mutate(sr = lapply(trk, summarize_sampling_rate)) %>%
dplyr::select(snail, sr) %>% unnest(cols = c(sr))
#summary of track sampling rate for each individual
dat_all -> mutate(sr = lapply(dat_all$trk, summarize_sampling_rate)) %>%
dplyr::select(snail, sr) %>% unnest(cols = c(sr))
read(dat_all)
view(dat_all)
